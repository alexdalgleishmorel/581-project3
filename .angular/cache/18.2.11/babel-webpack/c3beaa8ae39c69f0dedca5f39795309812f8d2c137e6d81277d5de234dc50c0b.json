{"ast":null,"code":"import { minBbox } from '../ops';\nimport { getCenterPoint } from '../utils';\nimport { Box } from './Box';\nimport { Dimensions } from './Dimensions';\nimport { FaceDetection } from './FaceDetection';\nimport { Point } from './Point';\nimport { Rect } from './Rect';\n// face alignment constants\nvar relX = 0.5;\nvar relY = 0.43;\nvar relScale = 0.45;\nvar FaceLandmarks = /** @class */function () {\n  function FaceLandmarks(relativeFaceLandmarkPositions, imgDims, shift) {\n    if (shift === void 0) {\n      shift = new Point(0, 0);\n    }\n    var width = imgDims.width,\n      height = imgDims.height;\n    this._imgDims = new Dimensions(width, height);\n    this._shift = shift;\n    this._positions = relativeFaceLandmarkPositions.map(function (pt) {\n      return pt.mul(new Point(width, height)).add(shift);\n    });\n  }\n  Object.defineProperty(FaceLandmarks.prototype, \"shift\", {\n    get: function () {\n      return new Point(this._shift.x, this._shift.y);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FaceLandmarks.prototype, \"imageWidth\", {\n    get: function () {\n      return this._imgDims.width;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FaceLandmarks.prototype, \"imageHeight\", {\n    get: function () {\n      return this._imgDims.height;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FaceLandmarks.prototype, \"positions\", {\n    get: function () {\n      return this._positions;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(FaceLandmarks.prototype, \"relativePositions\", {\n    get: function () {\n      var _this = this;\n      return this._positions.map(function (pt) {\n        return pt.sub(_this._shift).div(new Point(_this.imageWidth, _this.imageHeight));\n      });\n    },\n    enumerable: true,\n    configurable: true\n  });\n  FaceLandmarks.prototype.forSize = function (width, height) {\n    return new this.constructor(this.relativePositions, {\n      width: width,\n      height: height\n    });\n  };\n  FaceLandmarks.prototype.shiftBy = function (x, y) {\n    return new this.constructor(this.relativePositions, this._imgDims, new Point(x, y));\n  };\n  FaceLandmarks.prototype.shiftByPoint = function (pt) {\n    return this.shiftBy(pt.x, pt.y);\n  };\n  /**\r\n   * Aligns the face landmarks after face detection from the relative positions of the faces\r\n   * bounding box, or it's current shift. This function should be used to align the face images\r\n   * after face detection has been performed, before they are passed to the face recognition net.\r\n   * This will make the computed face descriptor more accurate.\r\n   *\r\n   * @param detection (optional) The bounding box of the face or the face detection result. If\r\n   * no argument was passed the position of the face landmarks are assumed to be relative to\r\n   * it's current shift.\r\n   * @returns The bounding box of the aligned face.\r\n   */\n  FaceLandmarks.prototype.align = function (detection, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (detection) {\n      var box = detection instanceof FaceDetection ? detection.box.floor() : new Box(detection);\n      return this.shiftBy(box.x, box.y).align(null, options);\n    }\n    var _a = Object.assign({}, {\n        useDlibAlignment: false,\n        minBoxPadding: 0.2\n      }, options),\n      useDlibAlignment = _a.useDlibAlignment,\n      minBoxPadding = _a.minBoxPadding;\n    if (useDlibAlignment) {\n      return this.alignDlib();\n    }\n    return this.alignMinBbox(minBoxPadding);\n  };\n  FaceLandmarks.prototype.alignDlib = function () {\n    var centers = this.getRefPointsForAlignment();\n    var leftEyeCenter = centers[0],\n      rightEyeCenter = centers[1],\n      mouthCenter = centers[2];\n    var distToMouth = function (pt) {\n      return mouthCenter.sub(pt).magnitude();\n    };\n    var eyeToMouthDist = (distToMouth(leftEyeCenter) + distToMouth(rightEyeCenter)) / 2;\n    var size = Math.floor(eyeToMouthDist / relScale);\n    var refPoint = getCenterPoint(centers);\n    // TODO: pad in case rectangle is out of image bounds\n    var x = Math.floor(Math.max(0, refPoint.x - relX * size));\n    var y = Math.floor(Math.max(0, refPoint.y - relY * size));\n    return new Rect(x, y, Math.min(size, this.imageWidth + x), Math.min(size, this.imageHeight + y));\n  };\n  FaceLandmarks.prototype.alignMinBbox = function (padding) {\n    var box = minBbox(this.positions);\n    return box.pad(box.width * padding, box.height * padding);\n  };\n  FaceLandmarks.prototype.getRefPointsForAlignment = function () {\n    throw new Error('getRefPointsForAlignment not implemented by base class');\n  };\n  return FaceLandmarks;\n}();\nexport { FaceLandmarks };","map":{"version":3,"names":["minBbox","getCenterPoint","Box","Dimensions","FaceDetection","Point","Rect","relX","relY","relScale","FaceLandmarks","relativeFaceLandmarkPositions","imgDims","shift","width","height","_imgDims","_shift","_positions","map","pt","mul","add","Object","defineProperty","prototype","get","x","y","enumerable","configurable","_this","sub","div","imageWidth","imageHeight","forSize","constructor","relativePositions","shiftBy","shiftByPoint","align","detection","options","box","floor","_a","assign","useDlibAlignment","minBoxPadding","alignDlib","alignMinBbox","centers","getRefPointsForAlignment","leftEyeCenter","rightEyeCenter","mouthCenter","distToMouth","magnitude","eyeToMouthDist","size","Math","refPoint","max","min","padding","positions","pad","Error"],"sources":["/Users/alexdalgleishmorel/Desktop/UofC/FALL 24/581/581-project3/node_modules/face-api.js/build/es6/classes/FaceLandmarks.js"],"sourcesContent":["import { minBbox } from '../ops';\r\nimport { getCenterPoint } from '../utils';\r\nimport { Box } from './Box';\r\nimport { Dimensions } from './Dimensions';\r\nimport { FaceDetection } from './FaceDetection';\r\nimport { Point } from './Point';\r\nimport { Rect } from './Rect';\r\n// face alignment constants\r\nvar relX = 0.5;\r\nvar relY = 0.43;\r\nvar relScale = 0.45;\r\nvar FaceLandmarks = /** @class */ (function () {\r\n    function FaceLandmarks(relativeFaceLandmarkPositions, imgDims, shift) {\r\n        if (shift === void 0) { shift = new Point(0, 0); }\r\n        var width = imgDims.width, height = imgDims.height;\r\n        this._imgDims = new Dimensions(width, height);\r\n        this._shift = shift;\r\n        this._positions = relativeFaceLandmarkPositions.map(function (pt) { return pt.mul(new Point(width, height)).add(shift); });\r\n    }\r\n    Object.defineProperty(FaceLandmarks.prototype, \"shift\", {\r\n        get: function () { return new Point(this._shift.x, this._shift.y); },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FaceLandmarks.prototype, \"imageWidth\", {\r\n        get: function () { return this._imgDims.width; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FaceLandmarks.prototype, \"imageHeight\", {\r\n        get: function () { return this._imgDims.height; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FaceLandmarks.prototype, \"positions\", {\r\n        get: function () { return this._positions; },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    Object.defineProperty(FaceLandmarks.prototype, \"relativePositions\", {\r\n        get: function () {\r\n            var _this = this;\r\n            return this._positions.map(function (pt) { return pt.sub(_this._shift).div(new Point(_this.imageWidth, _this.imageHeight)); });\r\n        },\r\n        enumerable: true,\r\n        configurable: true\r\n    });\r\n    FaceLandmarks.prototype.forSize = function (width, height) {\r\n        return new this.constructor(this.relativePositions, { width: width, height: height });\r\n    };\r\n    FaceLandmarks.prototype.shiftBy = function (x, y) {\r\n        return new this.constructor(this.relativePositions, this._imgDims, new Point(x, y));\r\n    };\r\n    FaceLandmarks.prototype.shiftByPoint = function (pt) {\r\n        return this.shiftBy(pt.x, pt.y);\r\n    };\r\n    /**\r\n     * Aligns the face landmarks after face detection from the relative positions of the faces\r\n     * bounding box, or it's current shift. This function should be used to align the face images\r\n     * after face detection has been performed, before they are passed to the face recognition net.\r\n     * This will make the computed face descriptor more accurate.\r\n     *\r\n     * @param detection (optional) The bounding box of the face or the face detection result. If\r\n     * no argument was passed the position of the face landmarks are assumed to be relative to\r\n     * it's current shift.\r\n     * @returns The bounding box of the aligned face.\r\n     */\r\n    FaceLandmarks.prototype.align = function (detection, options) {\r\n        if (options === void 0) { options = {}; }\r\n        if (detection) {\r\n            var box = detection instanceof FaceDetection\r\n                ? detection.box.floor()\r\n                : new Box(detection);\r\n            return this.shiftBy(box.x, box.y).align(null, options);\r\n        }\r\n        var _a = Object.assign({}, { useDlibAlignment: false, minBoxPadding: 0.2 }, options), useDlibAlignment = _a.useDlibAlignment, minBoxPadding = _a.minBoxPadding;\r\n        if (useDlibAlignment) {\r\n            return this.alignDlib();\r\n        }\r\n        return this.alignMinBbox(minBoxPadding);\r\n    };\r\n    FaceLandmarks.prototype.alignDlib = function () {\r\n        var centers = this.getRefPointsForAlignment();\r\n        var leftEyeCenter = centers[0], rightEyeCenter = centers[1], mouthCenter = centers[2];\r\n        var distToMouth = function (pt) { return mouthCenter.sub(pt).magnitude(); };\r\n        var eyeToMouthDist = (distToMouth(leftEyeCenter) + distToMouth(rightEyeCenter)) / 2;\r\n        var size = Math.floor(eyeToMouthDist / relScale);\r\n        var refPoint = getCenterPoint(centers);\r\n        // TODO: pad in case rectangle is out of image bounds\r\n        var x = Math.floor(Math.max(0, refPoint.x - (relX * size)));\r\n        var y = Math.floor(Math.max(0, refPoint.y - (relY * size)));\r\n        return new Rect(x, y, Math.min(size, this.imageWidth + x), Math.min(size, this.imageHeight + y));\r\n    };\r\n    FaceLandmarks.prototype.alignMinBbox = function (padding) {\r\n        var box = minBbox(this.positions);\r\n        return box.pad(box.width * padding, box.height * padding);\r\n    };\r\n    FaceLandmarks.prototype.getRefPointsForAlignment = function () {\r\n        throw new Error('getRefPointsForAlignment not implemented by base class');\r\n    };\r\n    return FaceLandmarks;\r\n}());\r\nexport { FaceLandmarks };\r\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,QAAQ;AAChC,SAASC,cAAc,QAAQ,UAAU;AACzC,SAASC,GAAG,QAAQ,OAAO;AAC3B,SAASC,UAAU,QAAQ,cAAc;AACzC,SAASC,aAAa,QAAQ,iBAAiB;AAC/C,SAASC,KAAK,QAAQ,SAAS;AAC/B,SAASC,IAAI,QAAQ,QAAQ;AAC7B;AACA,IAAIC,IAAI,GAAG,GAAG;AACd,IAAIC,IAAI,GAAG,IAAI;AACf,IAAIC,QAAQ,GAAG,IAAI;AACnB,IAAIC,aAAa,GAAG,aAAe,YAAY;EAC3C,SAASA,aAAaA,CAACC,6BAA6B,EAAEC,OAAO,EAAEC,KAAK,EAAE;IAClE,IAAIA,KAAK,KAAK,KAAK,CAAC,EAAE;MAAEA,KAAK,GAAG,IAAIR,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC;IAAE;IACjD,IAAIS,KAAK,GAAGF,OAAO,CAACE,KAAK;MAAEC,MAAM,GAAGH,OAAO,CAACG,MAAM;IAClD,IAAI,CAACC,QAAQ,GAAG,IAAIb,UAAU,CAACW,KAAK,EAAEC,MAAM,CAAC;IAC7C,IAAI,CAACE,MAAM,GAAGJ,KAAK;IACnB,IAAI,CAACK,UAAU,GAAGP,6BAA6B,CAACQ,GAAG,CAAC,UAAUC,EAAE,EAAE;MAAE,OAAOA,EAAE,CAACC,GAAG,CAAC,IAAIhB,KAAK,CAACS,KAAK,EAAEC,MAAM,CAAC,CAAC,CAACO,GAAG,CAACT,KAAK,CAAC;IAAE,CAAC,CAAC;EAC9H;EACAU,MAAM,CAACC,cAAc,CAACd,aAAa,CAACe,SAAS,EAAE,OAAO,EAAE;IACpDC,GAAG,EAAE,SAAAA,CAAA,EAAY;MAAE,OAAO,IAAIrB,KAAK,CAAC,IAAI,CAACY,MAAM,CAACU,CAAC,EAAE,IAAI,CAACV,MAAM,CAACW,CAAC,CAAC;IAAE,CAAC;IACpEC,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFP,MAAM,CAACC,cAAc,CAACd,aAAa,CAACe,SAAS,EAAE,YAAY,EAAE;IACzDC,GAAG,EAAE,SAAAA,CAAA,EAAY;MAAE,OAAO,IAAI,CAACV,QAAQ,CAACF,KAAK;IAAE,CAAC;IAChDe,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFP,MAAM,CAACC,cAAc,CAACd,aAAa,CAACe,SAAS,EAAE,aAAa,EAAE;IAC1DC,GAAG,EAAE,SAAAA,CAAA,EAAY;MAAE,OAAO,IAAI,CAACV,QAAQ,CAACD,MAAM;IAAE,CAAC;IACjDc,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFP,MAAM,CAACC,cAAc,CAACd,aAAa,CAACe,SAAS,EAAE,WAAW,EAAE;IACxDC,GAAG,EAAE,SAAAA,CAAA,EAAY;MAAE,OAAO,IAAI,CAACR,UAAU;IAAE,CAAC;IAC5CW,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFP,MAAM,CAACC,cAAc,CAACd,aAAa,CAACe,SAAS,EAAE,mBAAmB,EAAE;IAChEC,GAAG,EAAE,SAAAA,CAAA,EAAY;MACb,IAAIK,KAAK,GAAG,IAAI;MAChB,OAAO,IAAI,CAACb,UAAU,CAACC,GAAG,CAAC,UAAUC,EAAE,EAAE;QAAE,OAAOA,EAAE,CAACY,GAAG,CAACD,KAAK,CAACd,MAAM,CAAC,CAACgB,GAAG,CAAC,IAAI5B,KAAK,CAAC0B,KAAK,CAACG,UAAU,EAAEH,KAAK,CAACI,WAAW,CAAC,CAAC;MAAE,CAAC,CAAC;IAClI,CAAC;IACDN,UAAU,EAAE,IAAI;IAChBC,YAAY,EAAE;EAClB,CAAC,CAAC;EACFpB,aAAa,CAACe,SAAS,CAACW,OAAO,GAAG,UAAUtB,KAAK,EAAEC,MAAM,EAAE;IACvD,OAAO,IAAI,IAAI,CAACsB,WAAW,CAAC,IAAI,CAACC,iBAAiB,EAAE;MAAExB,KAAK,EAAEA,KAAK;MAAEC,MAAM,EAAEA;IAAO,CAAC,CAAC;EACzF,CAAC;EACDL,aAAa,CAACe,SAAS,CAACc,OAAO,GAAG,UAAUZ,CAAC,EAAEC,CAAC,EAAE;IAC9C,OAAO,IAAI,IAAI,CAACS,WAAW,CAAC,IAAI,CAACC,iBAAiB,EAAE,IAAI,CAACtB,QAAQ,EAAE,IAAIX,KAAK,CAACsB,CAAC,EAAEC,CAAC,CAAC,CAAC;EACvF,CAAC;EACDlB,aAAa,CAACe,SAAS,CAACe,YAAY,GAAG,UAAUpB,EAAE,EAAE;IACjD,OAAO,IAAI,CAACmB,OAAO,CAACnB,EAAE,CAACO,CAAC,EAAEP,EAAE,CAACQ,CAAC,CAAC;EACnC,CAAC;EACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACIlB,aAAa,CAACe,SAAS,CAACgB,KAAK,GAAG,UAAUC,SAAS,EAAEC,OAAO,EAAE;IAC1D,IAAIA,OAAO,KAAK,KAAK,CAAC,EAAE;MAAEA,OAAO,GAAG,CAAC,CAAC;IAAE;IACxC,IAAID,SAAS,EAAE;MACX,IAAIE,GAAG,GAAGF,SAAS,YAAYtC,aAAa,GACtCsC,SAAS,CAACE,GAAG,CAACC,KAAK,CAAC,CAAC,GACrB,IAAI3C,GAAG,CAACwC,SAAS,CAAC;MACxB,OAAO,IAAI,CAACH,OAAO,CAACK,GAAG,CAACjB,CAAC,EAAEiB,GAAG,CAAChB,CAAC,CAAC,CAACa,KAAK,CAAC,IAAI,EAAEE,OAAO,CAAC;IAC1D;IACA,IAAIG,EAAE,GAAGvB,MAAM,CAACwB,MAAM,CAAC,CAAC,CAAC,EAAE;QAAEC,gBAAgB,EAAE,KAAK;QAAEC,aAAa,EAAE;MAAI,CAAC,EAAEN,OAAO,CAAC;MAAEK,gBAAgB,GAAGF,EAAE,CAACE,gBAAgB;MAAEC,aAAa,GAAGH,EAAE,CAACG,aAAa;IAC9J,IAAID,gBAAgB,EAAE;MAClB,OAAO,IAAI,CAACE,SAAS,CAAC,CAAC;IAC3B;IACA,OAAO,IAAI,CAACC,YAAY,CAACF,aAAa,CAAC;EAC3C,CAAC;EACDvC,aAAa,CAACe,SAAS,CAACyB,SAAS,GAAG,YAAY;IAC5C,IAAIE,OAAO,GAAG,IAAI,CAACC,wBAAwB,CAAC,CAAC;IAC7C,IAAIC,aAAa,GAAGF,OAAO,CAAC,CAAC,CAAC;MAAEG,cAAc,GAAGH,OAAO,CAAC,CAAC,CAAC;MAAEI,WAAW,GAAGJ,OAAO,CAAC,CAAC,CAAC;IACrF,IAAIK,WAAW,GAAG,SAAAA,CAAUrC,EAAE,EAAE;MAAE,OAAOoC,WAAW,CAACxB,GAAG,CAACZ,EAAE,CAAC,CAACsC,SAAS,CAAC,CAAC;IAAE,CAAC;IAC3E,IAAIC,cAAc,GAAG,CAACF,WAAW,CAACH,aAAa,CAAC,GAAGG,WAAW,CAACF,cAAc,CAAC,IAAI,CAAC;IACnF,IAAIK,IAAI,GAAGC,IAAI,CAAChB,KAAK,CAACc,cAAc,GAAGlD,QAAQ,CAAC;IAChD,IAAIqD,QAAQ,GAAG7D,cAAc,CAACmD,OAAO,CAAC;IACtC;IACA,IAAIzB,CAAC,GAAGkC,IAAI,CAAChB,KAAK,CAACgB,IAAI,CAACE,GAAG,CAAC,CAAC,EAAED,QAAQ,CAACnC,CAAC,GAAIpB,IAAI,GAAGqD,IAAK,CAAC,CAAC;IAC3D,IAAIhC,CAAC,GAAGiC,IAAI,CAAChB,KAAK,CAACgB,IAAI,CAACE,GAAG,CAAC,CAAC,EAAED,QAAQ,CAAClC,CAAC,GAAIpB,IAAI,GAAGoD,IAAK,CAAC,CAAC;IAC3D,OAAO,IAAItD,IAAI,CAACqB,CAAC,EAAEC,CAAC,EAAEiC,IAAI,CAACG,GAAG,CAACJ,IAAI,EAAE,IAAI,CAAC1B,UAAU,GAAGP,CAAC,CAAC,EAAEkC,IAAI,CAACG,GAAG,CAACJ,IAAI,EAAE,IAAI,CAACzB,WAAW,GAAGP,CAAC,CAAC,CAAC;EACpG,CAAC;EACDlB,aAAa,CAACe,SAAS,CAAC0B,YAAY,GAAG,UAAUc,OAAO,EAAE;IACtD,IAAIrB,GAAG,GAAG5C,OAAO,CAAC,IAAI,CAACkE,SAAS,CAAC;IACjC,OAAOtB,GAAG,CAACuB,GAAG,CAACvB,GAAG,CAAC9B,KAAK,GAAGmD,OAAO,EAAErB,GAAG,CAAC7B,MAAM,GAAGkD,OAAO,CAAC;EAC7D,CAAC;EACDvD,aAAa,CAACe,SAAS,CAAC4B,wBAAwB,GAAG,YAAY;IAC3D,MAAM,IAAIe,KAAK,CAAC,wDAAwD,CAAC;EAC7E,CAAC;EACD,OAAO1D,aAAa;AACxB,CAAC,CAAC,CAAE;AACJ,SAASA,aAAa","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}